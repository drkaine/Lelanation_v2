name: Companion Windows Signed Build

on:
  workflow_dispatch:
    inputs:
      sign:
        description: "Sign installer with code-signing certificate"
        required: false
        default: true
        type: boolean
  push:
    tags:
      - "v*"
      - "companion-v*"

permissions:
  contents: write

jobs:
  build-windows:
    name: Build and Sign Windows Installer
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
        working-directory: companion-app
    env:
      SHOULD_SIGN: ${{ github.event_name == 'push' || inputs.sign }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install workspace dependencies
        working-directory: .
        run: npm ci

      - name: Copy shared icons to companion-app public
        working-directory: .
        run: |
          $src = Join-Path $PWD "packages\shared-theme\icons"
          $dst = Join-Path $PWD "companion-app\public\icons"
          if (Test-Path $dst) { Remove-Item -Recurse -Force $dst }
          Copy-Item -Path $src -Destination $dst -Recurse -Force
          Write-Host "Copied shared icons to $dst"

      - name: Build Tauri Windows bundle
        run: npm run tauri build

      - name: Assert signing secrets present
        if: env.SHOULD_SIGN == 'true'
        run: |
          if ("${{ secrets.WINDOWS_CODESIGN_PFX_B64 }}" -eq "") {
            throw "Missing secret WINDOWS_CODESIGN_PFX_B64"
          }
          if ("${{ secrets.WINDOWS_CODESIGN_PASSWORD }}" -eq "") {
            throw "Missing secret WINDOWS_CODESIGN_PASSWORD"
          }

      - name: Import signing certificate
        if: env.SHOULD_SIGN == 'true'
        run: |
          $pfxPath = Join-Path $env:RUNNER_TEMP "codesign.pfx"
          [System.IO.File]::WriteAllBytes($pfxPath, [System.Convert]::FromBase64String("${{ secrets.WINDOWS_CODESIGN_PFX_B64 }}"))
          echo "PFX_PATH=$pfxPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Locate signtool.exe
        if: env.SHOULD_SIGN == 'true'
        shell: pwsh
        run: |
          $sdkRoot = "C:\Program Files (x86)\Windows Kits\10\bin"
          $signtool = Get-ChildItem -Path $sdkRoot -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "x64" } |
            Sort-Object { $_.Directory.Name } -Descending |
            Select-Object -First 1
          if (!$signtool) { throw "signtool.exe not found under $sdkRoot" }
          $dir = $signtool.DirectoryName
          Write-Host "Found signtool at $dir"
          echo "$dir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Sign all Windows bundles (.exe/.msi)
        if: env.SHOULD_SIGN == 'true'
        run: |
          $bundleRoot = Join-Path $PWD "src-tauri\target\release\bundle"
          if (!(Test-Path $bundleRoot)) {
            throw "Bundle directory not found: $bundleRoot"
          }

          $filesToSign = Get-ChildItem -Path $bundleRoot -Recurse -File | Where-Object { $_.Extension -in ".exe", ".msi" }
          if ($filesToSign.Count -eq 0) {
            throw "No .exe/.msi files found to sign in $bundleRoot"
          }

          foreach ($file in $filesToSign) {
            Write-Host "Signing $($file.FullName)"
            & signtool sign `
              /f "$env:PFX_PATH" `
              /p "${{ secrets.WINDOWS_CODESIGN_PASSWORD }}" `
              /fd SHA256 `
              /td SHA256 `
              /tr "http://timestamp.digicert.com" `
              /d "Lelanation Companion" `
              "$($file.FullName)"

            if ($LASTEXITCODE -ne 0) {
              throw "signtool failed for $($file.FullName)"
            }
          }

      - name: Verify Authenticode signature
        if: env.SHOULD_SIGN == 'true'
        run: |
          $bundleRoot = Join-Path $PWD "src-tauri\target\release\bundle"
          $signedFiles = Get-ChildItem -Path $bundleRoot -Recurse -File | Where-Object { $_.Extension -in ".exe", ".msi" }
          foreach ($file in $signedFiles) {
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            Write-Host "$($file.Name): $($sig.Status)"
            if ($sig.Status -ne "Valid") {
              throw "Invalid signature for $($file.FullName): $($sig.Status)"
            }
          }

      - name: Collect signed installer in installer folder
        run: |
          $nsisDir = Join-Path $PWD "src-tauri\target\release\bundle\nsis"
          if (!(Test-Path $nsisDir)) {
            throw "NSIS output folder not found: $nsisDir"
          }

          $installer = Get-ChildItem -Path $nsisDir -File | Where-Object { $_.Extension -eq ".exe" } | Select-Object -First 1
          if (!$installer) {
            throw "No NSIS installer .exe found in $nsisDir"
          }

          $destDir = Join-Path $env:GITHUB_WORKSPACE "installer"
          New-Item -ItemType Directory -Force -Path $destDir | Out-Null
          $dest = Join-Path $destDir "Lelanation.exe"
          Copy-Item -Path $installer.FullName -Destination $dest -Force
          Write-Host "Installer exported to $dest"

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: lelanation-windows-installer
          path: installer/Lelanation.exe
          if-no-files-found: error

      - name: Publish installer on GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: installer/Lelanation.exe
