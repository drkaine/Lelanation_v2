name: Companion Windows Signed Build

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g. 0.4.0). Leave empty for dev build without release."
        required: false
        type: string
      sign:
        description: "Sign installer with code-signing certificate"
        required: false
        default: true
        type: boolean
  push:
    tags:
      - "v*"
      - "companion-v*"

permissions:
  contents: write

jobs:
  build-windows:
    name: Build and Sign Windows Installer
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
        working-directory: companion-app
    env:
      SHOULD_SIGN: ${{ github.event_name == 'push' || inputs.sign }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve version
        id: version
        working-directory: .
        run: |
          $ver = ""
          if ("${{ inputs.version }}".Trim()) {
            $ver = "${{ inputs.version }}".Trim()
          } elseif ("${{ github.ref }}".StartsWith("refs/tags/")) {
            $ver = "${{ github.ref_name }}" -replace '^(companion-)?v', ''
          }
          if ($ver) {
            Write-Host "Release version: $ver"
            echo "value=$ver" >> $env:GITHUB_OUTPUT
            echo "is_release=true" >> $env:GITHUB_OUTPUT
          } else {
            $fallback = (Get-Content "companion-app\src-tauri\tauri.conf.json" | ConvertFrom-Json).version
            Write-Host "Dev build, using version from config: $fallback"
            echo "value=$fallback" >> $env:GITHUB_OUTPUT
            echo "is_release=false" >> $env:GITHUB_OUTPUT
          }

      - name: Inject version into config files
        if: steps.version.outputs.is_release == 'true'
        working-directory: .
        run: |
          $version = "${{ steps.version.outputs.value }}"
          # tauri.conf.json
          $tauriConf = "companion-app\src-tauri\tauri.conf.json"
          (Get-Content $tauriConf -Raw) -replace '"version":\s*"[^"]+"', "`"version`": `"$version`"" |
            Set-Content $tauriConf -NoNewline
          # Cargo.toml (only the package version at start of line, not dependency versions)
          $cargo = "companion-app\src-tauri\Cargo.toml"
          (Get-Content $cargo -Raw) -replace '(?m)^version\s*=\s*"[^"]+"', "version = `"$version`"" |
            Set-Content $cargo -NoNewline
          # package.json
          $pkg = "companion-app\package.json"
          (Get-Content $pkg -Raw) -replace '"version":\s*"[^"]+"', "`"version`": `"$version`"" |
            Set-Content $pkg -NoNewline
          Write-Host "All version files set to $version"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install workspace dependencies
        working-directory: .
        run: npm ci

      - name: Copy shared icons to companion-app public
        working-directory: .
        run: |
          $src = Join-Path $PWD "packages\shared-theme\icons"
          $dst = Join-Path $PWD "companion-app\public\icons"
          if (Test-Path $dst) { Remove-Item -Recurse -Force $dst }
          Copy-Item -Path $src -Destination $dst -Recurse -Force
          Write-Host "Copied shared icons to $dst"

      - name: Build Tauri Windows bundle
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ""
        run: npm run tauri build

      - name: Assert signing secrets present
        if: env.SHOULD_SIGN == 'true'
        run: |
          if ("${{ secrets.WINDOWS_CODESIGN_PFX_B64 }}" -eq "") {
            throw "Missing secret WINDOWS_CODESIGN_PFX_B64"
          }
          if ("${{ secrets.WINDOWS_CODESIGN_PASSWORD }}" -eq "") {
            throw "Missing secret WINDOWS_CODESIGN_PASSWORD"
          }

      - name: Import signing certificate
        if: env.SHOULD_SIGN == 'true'
        run: |
          $pfxPath = Join-Path $env:RUNNER_TEMP "codesign.pfx"
          [System.IO.File]::WriteAllBytes($pfxPath, [System.Convert]::FromBase64String("${{ secrets.WINDOWS_CODESIGN_PFX_B64 }}"))
          echo "PFX_PATH=$pfxPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Locate signtool.exe
        if: env.SHOULD_SIGN == 'true'
        shell: pwsh
        run: |
          $sdkRoot = "C:\Program Files (x86)\Windows Kits\10\bin"
          $signtool = Get-ChildItem -Path $sdkRoot -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "x64" } |
            Sort-Object { $_.Directory.Name } -Descending |
            Select-Object -First 1
          if (!$signtool) { throw "signtool.exe not found under $sdkRoot" }
          $dir = $signtool.DirectoryName
          Write-Host "Found signtool at $dir"
          echo "$dir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Sign all Windows bundles (.exe/.msi)
        if: env.SHOULD_SIGN == 'true'
        run: |
          $bundleRoot = Join-Path $PWD "src-tauri\target\release\bundle"
          if (!(Test-Path $bundleRoot)) {
            throw "Bundle directory not found: $bundleRoot"
          }

          $filesToSign = Get-ChildItem -Path $bundleRoot -Recurse -File | Where-Object { $_.Extension -in ".exe", ".msi" }
          if ($filesToSign.Count -eq 0) {
            throw "No .exe/.msi files found to sign in $bundleRoot"
          }

          foreach ($file in $filesToSign) {
            Write-Host "Signing $($file.FullName)"
            & signtool sign `
              /f "$env:PFX_PATH" `
              /p "${{ secrets.WINDOWS_CODESIGN_PASSWORD }}" `
              /fd SHA256 `
              /td SHA256 `
              /tr "http://timestamp.digicert.com" `
              /d "Lelanation Companion" `
              "$($file.FullName)"

            if ($LASTEXITCODE -ne 0) {
              throw "signtool failed for $($file.FullName)"
            }
          }

      - name: Verify Authenticode signature
        if: env.SHOULD_SIGN == 'true'
        run: |
          $bundleRoot = Join-Path $PWD "src-tauri\target\release\bundle"
          $signedFiles = Get-ChildItem -Path $bundleRoot -Recurse -File | Where-Object { $_.Extension -in ".exe", ".msi" }
          foreach ($file in $signedFiles) {
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            Write-Host "$($file.Name): $($sig.Status)"
            # Self-signed certs return UnknownError (signature present but chain untrusted).
            # Only fail if the file has no signature at all.
            if ($sig.Status -eq "NotSigned") {
              throw "File is not signed: $($file.FullName)"
            }
            Write-Host "  -> Signature present (status: $($sig.Status))"
          }

      - name: Collect signed installer and updater bundle
        run: |
          $nsisDir = Join-Path $PWD "src-tauri\target\release\bundle\nsis"
          if (!(Test-Path $nsisDir)) {
            throw "NSIS output folder not found: $nsisDir"
          }

          $destDir = Join-Path $env:GITHUB_WORKSPACE "installer"
          New-Item -ItemType Directory -Force -Path $destDir | Out-Null

          $installer = Get-ChildItem -Path $nsisDir -File | Where-Object { $_.Extension -eq ".exe" } | Select-Object -First 1
          if (!$installer) {
            throw "No NSIS installer .exe found in $nsisDir"
          }
          $dest = Join-Path $destDir "Lelanation.exe"
          Copy-Item -Path $installer.FullName -Destination $dest -Force
          Write-Host "Installer exported to $dest"

          $nsisZip = Get-ChildItem -Path $nsisDir -File | Where-Object { $_.Name -like "*.nsis.zip" } | Select-Object -First 1
          if ($nsisZip) {
            Copy-Item -Path $nsisZip.FullName -Destination (Join-Path $destDir $nsisZip.Name) -Force
            Write-Host "Updater bundle: $($nsisZip.Name)"
            echo "NSIS_ZIP_NAME=$($nsisZip.Name)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          }

          $nsisZipSig = Get-ChildItem -Path $nsisDir -File | Where-Object { $_.Name -like "*.nsis.zip.sig" } | Select-Object -First 1
          if ($nsisZipSig) {
            $sig = Get-Content -Path $nsisZipSig.FullName -Raw
            echo "NSIS_ZIP_SIG=$sig" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            Write-Host "Signature captured"
          }

      - name: Generate latest.json for auto-updater
        if: steps.version.outputs.is_release == 'true'
        run: |
          $version = "${{ steps.version.outputs.value }}"
          $tag = "companion-v$version"
          $sig = $env:NSIS_ZIP_SIG
          $zipName = $env:NSIS_ZIP_NAME

          if (-not $sig -or -not $zipName) {
            Write-Host "::warning::Skipping latest.json â€“ no updater signature found (TAURI_SIGNING_PRIVATE_KEY not set?)"
            exit 0
          }

          $url = "https://github.com/drkaine/Lelanation_v2/releases/download/$tag/$zipName"
          $pubDate = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")

          $json = @{
            version = $version
            notes = "Lelanation Companion v$version"
            pub_date = $pubDate
            platforms = @{
              "windows-x86_64" = @{
                signature = $sig
                url = $url
              }
            }
          } | ConvertTo-Json -Depth 4

          $destDir = Join-Path $env:GITHUB_WORKSPACE "installer"
          $json | Set-Content (Join-Path $destDir "latest.json") -Encoding UTF8
          Write-Host "latest.json generated"

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: lelanation-windows-installer
          path: |
            installer/Lelanation.exe
            installer/latest.json
            installer/*.nsis.zip
          if-no-files-found: error

      - name: Create tag and publish GitHub Release
        if: steps.version.outputs.is_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        working-directory: .
        run: |
          $version = "${{ steps.version.outputs.value }}"
          $tag = "companion-v$version"

          $existingTag = git tag -l $tag 2>$null
          if (-not $existingTag) {
            git tag $tag
            git push origin $tag
            Write-Host "Created and pushed tag $tag"
          } else {
            Write-Host "Tag $tag already exists"
          }

          $assets = @("installer/Lelanation.exe")
          if (Test-Path "installer/latest.json") { $assets += "installer/latest.json" }
          $nsisZip = Get-ChildItem "installer" -Filter "*.nsis.zip" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($nsisZip) { $assets += $nsisZip.FullName }

          gh release create $tag @assets `
            --title "Lelanation Companion v$version" `
            --generate-notes
          Write-Host "Published release $tag"
