name: Companion Windows Signed Build

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g. 0.4.0). Leave empty for dev build without release."
        required: false
        type: string
      sign:
        description: "Sign installer with code-signing certificate"
        required: false
        default: true
        type: boolean
  push:
    tags:
      - "v*"
      - "companion-v*"

permissions:
  contents: write

jobs:
  build-windows:
    name: Build and Sign Windows Installer
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
        working-directory: companion-app
    env:
      SHOULD_SIGN: ${{ github.event_name == 'push' || inputs.sign }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve version
        id: version
        working-directory: .
        run: |
          $ver = ""
          if ("${{ inputs.version }}".Trim()) {
            $ver = "${{ inputs.version }}".Trim()
          } elseif ("${{ github.ref }}".StartsWith("refs/tags/")) {
            $ver = "${{ github.ref_name }}" -replace '^(companion-)?v', ''
          }
          if ($ver) {
            Write-Host "Release version: $ver"
            echo "value=$ver" >> $env:GITHUB_OUTPUT
            echo "is_release=true" >> $env:GITHUB_OUTPUT
          } else {
            $fallback = (Get-Content "companion-app\src-tauri\tauri.conf.json" | ConvertFrom-Json).version
            Write-Host "Dev build, using version from config: $fallback"
            echo "value=$fallback" >> $env:GITHUB_OUTPUT
            echo "is_release=false" >> $env:GITHUB_OUTPUT
          }

      - name: Inject version into config files
        if: steps.version.outputs.is_release == 'true'
        working-directory: .
        run: |
          $version = "${{ steps.version.outputs.value }}"
          # tauri.conf.json
          $tauriConf = "companion-app\src-tauri\tauri.conf.json"
          (Get-Content $tauriConf -Raw) -replace '"version":\s*"[^"]+"', "`"version`": `"$version`"" |
            Set-Content $tauriConf -NoNewline
          # Cargo.toml
          $cargo = "companion-app\src-tauri\Cargo.toml"
          (Get-Content $cargo -Raw) -replace 'version\s*=\s*"[^"]+"', "version = `"$version`"" |
            Set-Content $cargo -NoNewline
          # package.json
          $pkg = "companion-app\package.json"
          (Get-Content $pkg -Raw) -replace '"version":\s*"[^"]+"', "`"version`": `"$version`"" |
            Set-Content $pkg -NoNewline
          Write-Host "All version files set to $version"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install workspace dependencies
        working-directory: .
        run: npm ci

      - name: Copy shared icons to companion-app public
        working-directory: .
        run: |
          $src = Join-Path $PWD "packages\shared-theme\icons"
          $dst = Join-Path $PWD "companion-app\public\icons"
          if (Test-Path $dst) { Remove-Item -Recurse -Force $dst }
          Copy-Item -Path $src -Destination $dst -Recurse -Force
          Write-Host "Copied shared icons to $dst"

      - name: Build Tauri Windows bundle
        run: npm run tauri build

      - name: Assert signing secrets present
        if: env.SHOULD_SIGN == 'true'
        run: |
          if ("${{ secrets.WINDOWS_CODESIGN_PFX_B64 }}" -eq "") {
            throw "Missing secret WINDOWS_CODESIGN_PFX_B64"
          }
          if ("${{ secrets.WINDOWS_CODESIGN_PASSWORD }}" -eq "") {
            throw "Missing secret WINDOWS_CODESIGN_PASSWORD"
          }

      - name: Import signing certificate
        if: env.SHOULD_SIGN == 'true'
        run: |
          $pfxPath = Join-Path $env:RUNNER_TEMP "codesign.pfx"
          [System.IO.File]::WriteAllBytes($pfxPath, [System.Convert]::FromBase64String("${{ secrets.WINDOWS_CODESIGN_PFX_B64 }}"))
          echo "PFX_PATH=$pfxPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Locate signtool.exe
        if: env.SHOULD_SIGN == 'true'
        shell: pwsh
        run: |
          $sdkRoot = "C:\Program Files (x86)\Windows Kits\10\bin"
          $signtool = Get-ChildItem -Path $sdkRoot -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match "x64" } |
            Sort-Object { $_.Directory.Name } -Descending |
            Select-Object -First 1
          if (!$signtool) { throw "signtool.exe not found under $sdkRoot" }
          $dir = $signtool.DirectoryName
          Write-Host "Found signtool at $dir"
          echo "$dir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Sign all Windows bundles (.exe/.msi)
        if: env.SHOULD_SIGN == 'true'
        run: |
          $bundleRoot = Join-Path $PWD "src-tauri\target\release\bundle"
          if (!(Test-Path $bundleRoot)) {
            throw "Bundle directory not found: $bundleRoot"
          }

          $filesToSign = Get-ChildItem -Path $bundleRoot -Recurse -File | Where-Object { $_.Extension -in ".exe", ".msi" }
          if ($filesToSign.Count -eq 0) {
            throw "No .exe/.msi files found to sign in $bundleRoot"
          }

          foreach ($file in $filesToSign) {
            Write-Host "Signing $($file.FullName)"
            & signtool sign `
              /f "$env:PFX_PATH" `
              /p "${{ secrets.WINDOWS_CODESIGN_PASSWORD }}" `
              /fd SHA256 `
              /td SHA256 `
              /tr "http://timestamp.digicert.com" `
              /d "Lelanation Companion" `
              "$($file.FullName)"

            if ($LASTEXITCODE -ne 0) {
              throw "signtool failed for $($file.FullName)"
            }
          }

      - name: Verify Authenticode signature
        if: env.SHOULD_SIGN == 'true'
        run: |
          $bundleRoot = Join-Path $PWD "src-tauri\target\release\bundle"
          $signedFiles = Get-ChildItem -Path $bundleRoot -Recurse -File | Where-Object { $_.Extension -in ".exe", ".msi" }
          foreach ($file in $signedFiles) {
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            Write-Host "$($file.Name): $($sig.Status)"
            # Self-signed certs return UnknownError (signature present but chain untrusted).
            # Only fail if the file has no signature at all.
            if ($sig.Status -eq "NotSigned") {
              throw "File is not signed: $($file.FullName)"
            }
            Write-Host "  -> Signature present (status: $($sig.Status))"
          }

      - name: Collect signed installer in installer folder
        run: |
          $nsisDir = Join-Path $PWD "src-tauri\target\release\bundle\nsis"
          if (!(Test-Path $nsisDir)) {
            throw "NSIS output folder not found: $nsisDir"
          }

          $installer = Get-ChildItem -Path $nsisDir -File | Where-Object { $_.Extension -eq ".exe" } | Select-Object -First 1
          if (!$installer) {
            throw "No NSIS installer .exe found in $nsisDir"
          }

          $destDir = Join-Path $env:GITHUB_WORKSPACE "installer"
          New-Item -ItemType Directory -Force -Path $destDir | Out-Null
          $dest = Join-Path $destDir "Lelanation.exe"
          Copy-Item -Path $installer.FullName -Destination $dest -Force
          Write-Host "Installer exported to $dest"

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: lelanation-windows-installer
          path: installer/Lelanation.exe
          if-no-files-found: error

      - name: Create tag and publish GitHub Release
        if: steps.version.outputs.is_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        working-directory: .
        run: |
          $version = "${{ steps.version.outputs.value }}"
          $tag = "companion-v$version"

          # Create tag if it doesn't exist yet (workflow_dispatch case)
          $existingTag = git tag -l $tag 2>$null
          if (-not $existingTag) {
            git tag $tag
            git push origin $tag
            Write-Host "Created and pushed tag $tag"
          } else {
            Write-Host "Tag $tag already exists"
          }

          # Create GitHub release with the installer
          gh release create $tag `
            "installer/Lelanation.exe" `
            --title "Lelanation Companion v$version" `
            --generate-notes
          Write-Host "Published release $tag"
